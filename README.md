# 软件设计之禅

没想到我居然膨胀到想写这种题目，一直以来都想把自己的一些感悟和思考整理一下记录下来。不涉及技术细节，基本上都是一些又玄又虚的东西，这个题目听起来又虚又玄，感觉非常适合，就暂且叫这个吧。

### 设计模式非模式——无即是有
说到软件设计不得不提设计模式，GoF的那本Design Pattens是很多人走上系统化理论化的软件设计之路的启蒙书，打开了一扇新大门。但是设计模式中的模式二字会让人误以为这是一本模式手册，可以死记硬背，碰到实际任务就去套用模式，这是错误的方向。学习设计模式的核心在于真正理解设计背后的原理，理解这些模式是如何设计出来的。如同千变万化的大自然背后往往都会有一些简单的规则，看似多种多样的模式背后都有着简单的设计原则，遵循这些原则，针对各种任务的不同模式都可以推演出来。

高内聚低耦合原则。这个说起来人人知道，但真正能做好的很少。同一功能的代码尽量聚合少分散，不同功能的代码不要掺在一起。尽量减少代码模块之间不必要的联系。高耦合是软件设计的大敌，耦合越多意味着代码功能越缠杂不清，牵一发而动全身，修改难度越大，越容易出错，出现问题越难定位。

开放封闭原则（ open-close）。基础原则：代码应该对功能扩展开放对修改封闭，增加新功能应尽量少改动原有代码。高级原则：计划中不变的功能代码是封闭的，只可修改不可扩展；而计划中可变化扩展的功能代码是开放的，无需修改即可扩展。开放指增加抽象，通过中间层实现功能扩展。相应地，封闭指减少抽象，固化逻辑，提高运行效率和可维护性。高级原则是更高层次上的开放和封闭性，是对基础原则的制衡，避免滥用。

这两条原则并非互相独立，而是相辅相成互相渗透的。说起来容易做起来难，做到什么样才算好？可以将对原有代码的改动量做为一定程度的量化标准。改动5行代码显然比改10行代码好，同一个文件改5行代码显然比5个文件每个改一行好，同一个文件中一个地方改5行代码显然比5个地方改5行要好。如果新增一个功能要在好几个文件中改一堆代码，这时就要想想是不是设计有问题了。对已有代码的改动影响开发效率而且容易出错。代码改动量指示了原有设计的高内聚低耦合和开放封闭性是否合理。好的设计会让实现新需求如丝般顺滑，效率成倍提高。

设计模式还有一些更具体的基本原则，有的比较浅显有的没有脱离前两条原则范围，比如单一职责和接口隔离是高内聚，依赖倒置和迪米特原则都是低耦合，违反里氏替换原则实际上是开放封闭性有问题，就不赘述了。

设计模式四大境界：境界零，菜鸟，心中无模式，手中亦无模式。境界一，入门，心中有模式，手中无模式。境界二，高手，心中有模式，手中亦有模式。境界三，大师，心中无模式，出手皆模式。设计模式学习应该从厚到薄，逐渐吃透每个模式，领悟设计思想，理解设计原则，然后忘掉所有模式，像张无忌学太极拳一样，忘掉具体招式才能融会贯通，达到无招胜有招的境界。


**设计的进化——少即是多**

现实世界是复杂多变的，不管一开始考虑多周到，总会有意想不到的情况发生，所以设计必然要不断进化。设计能力学习到一定程度后，容易出现另一个极端，即从缺乏设计到过度设计。比如开放封闭基础原则运用不当的话，一开始就考虑到所有可能的功能扩展，必然会导致过度设计。除非有确切经验或者确定的规划，预想中的很多需求变化可能根本不会发生，为这些莫须有的需求做设计会带来很多不必要的负担。

如同生物进化一样，如果不考虑环境需要，一鼓脑把所有器官都长上，大角也要，尖牙利爪也要，翅膀也要，毒牙也要，甲壳也要，水里能游地上能跑空中能飞，纸面上的适应能力和战斗力爆表，但是实际上很多能力根本用不到，徒增大量负担和消耗，并不适合生存。生物进化是循序渐进的，设计也应该是同样的，适用即可，随需而变，不断进化。但并不是说不考虑未来的需求，要合理预测，谨慎推进，避免过度设计。


**重构熵减——慢即是快**

设计的进化主要靠重构推动，应该什么时候去重构代码呢？一发现代码的设计问题马上就去重构不一定是最好的选择，为了提高效率减少不必要的浪费，可以采用懒惰算法。设定一个缓冲时间，如果觉得某块代码设计有问题需要重构，估算一下重构需要的时间，如果少于这个缓冲期就先放着，等到下次实现某个需求需要改动的时候再一起做，在这期间可以考虑可能的重构方案。这样做一来可以避免过早重构做无用功，不一定能满足新需求。二来让重构设计有新需求做参考，使设计能够支持一系列类似的需求，以后类似需求可以很快实现。这里就是之前说的合理预测未来新需求，既然某个需求已经出现，那么类似的需求也很有可能会出现，新设计最好能够支持这一类需求。如果发现重构某块代码需要的时间超过缓冲时间，即使没有新需求也可以开始重构了，避免设计不良的代码堆积起来。建议这个时间一般为2小时（已考虑好重构方案），最多一天。如果某块代码堆积到需要一天时间才能重构完，那实在应该早点动手的。

不良代码的复杂性是指数增加的，1千行不良代码的重构难度是1的话，1万行的难度可能就是100，10万行的难度就是噩梦般天文数字。大规模堆积的不良代码就是传说中的屎山，盘根错节千丝万缕，神仙来了也难救。由此引入一个概念叫代码的熵，即代码的混乱程度，用当前代码重构到可能最优设计需要的时间来度量，也代表了代码的可控性。如同永恒的宇宙规律，不做任何努力的话熵永远是增大的，低熵代表着秩序与生命。适当的时候停下来梳理一下代码做重构，将代码的熵保持在可控范围内，看似多花了一些额外时间，慢了一点，实际上设计的进化会提高整体效率，磨刀不误砍柴工。代码质量直接决定了软件质量，设计良好的代码直接产生的bug会少很多，出现bug后定位修改也会更容易。

光靠工程师自发地做重构改进是远远不够的，公司还应该有自上而下的制度性的培训、引导和督促机制，最终建立一个完整的软件设计体系，上到架构师下到普通工程师，都对软件设计重视起来，对代码质量重视起来。


**元编程—— 一即是多**

元编程, 即meta-programming，用程序生成程序，是一种超越程序代码之上更高层次的抽象。业务需求多变，产品经理一天一个想法，程序员天天加班都赶不上怎么办？可以试试元编程这个核武库。业务需求多变，总会有一些不变的东西，比如一些最基本的操作或元素，通过将这些操作和元素用一定的逻辑方式排列组合，可以满足不同的业务需求。将最基本的操作和元素用原生程序实现成最小单位，通过配置文件或脚本来组织粘合起来，实现灵活多变的功能，就是元编程的基本思想。教产品经理写写配置脚本就能实现大部分需求变动，他们想怎么玩就怎么玩，程序员就可以早点下班了。

元编程做到极致就是设计一门新语言，一般称为DSL（Domain Specific Language，领域特定语言）。可以自己设计实现特定语法的简单脚本引擎，也可以直接采用现成的各种轻量通用脚本引擎，有特殊要求的还可以利用lex yacc bison等工具实现特定语法的语言解释器，如果恰好在用某些动态语言做开发也可以利用各种动态特性比如反射动态绑定等等。回想一下之前说的两条基本设计原则，元编程其实是开放封闭原则在更高维度上的产物。


**尾声**

软件设计是门艺术，艺术是没法批量制造的。冰冻三尺非一日之寒，对个人来说需要长时间的领悟积累，对公司来说建立人才体系也需要长期持续的投入。

虽然我说得天花乱坠，实际工作中还是会有各种脏活累活是逃避不掉的，该加班还得加。

理想情况很难达到，实际上远不可能做到完美，但是应该有追求完美的心态和勇气。

xuruijun
2019.11.15
